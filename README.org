#+TITLE: About functional-json

This is a fork of [[https://marijnhaverbeke.nl/st-json/][ST-JSON]] with extra utilities to streamline
JSON processing and work with JSON from the REPL.

This fork aims to be backwards compatible with ST-JSON.

* Basic Usage

** Load JSON data using `fj:read-json` and `fj:with-keys` to access fields.

Field names can be "strings", :keywords, or 'symbols.

#+BEGIN_SRC lisp :results output
  (ql:quickload '(:functional-json :dexador))

  (let ((url "https://api.github.com/repos/jl2/functional-json/contents/")
        (total-size 0))

    (dolist (json (fj:read-json (dex:get url)))
      (fj:with-keys ((name :name)
                     (size "size")
                     (html '_links :html)) json
        (incf total-size size)
        (format t
                "~s, ~a bytes~%~s~%~%"
                name size html)))
    total-size)
#+END_SRC

** Use `fj:jso位` to create access functions.

#+BEGIN_SRC lisp :results result
  (ql:quickload '(:functional-json :dexador))

  (let ((url "https://api.github.com/repos/jl2/functional-json/contents/"))
    (mapcar (fj:jso位 :_links :html)
            (fj:read-json (dex:get url)))))
#+END_SRC

** Use `fj:at` to access to fields.

#+BEGIN_SRC lisp :results output
  (ql:quickload '(:functional-json :dexador))

  (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
         (json-list (fj:read-json (dex:get url :want-stream t)))
         (json (first json-list)))

    (format t "First: ~a~%" (fj:at json :_links))
    (rotatef (fj:at json :_links :git) (fj:at json :_links :self) )
    (format t "Swapped: ~a~%" (fj:at json :_links))
    (rotatef (fj:at json :_links :git) (fj:at json :_links :self) )
    (format t "Swapped back: ~a~%" (fj:at json :_links)))
#+END_SRC

** Use `fj:at位` to create curried field access functions.

#+BEGIN_SRC lisp :results output
  (ql:quickload '(:functional-json :dexador :alexandria))
  (use-package :alexandria)

  (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
         (json-list (fj:read-json (dex:get url :want-stream t)))
         (json (first json-list))
         (links (fj:at位 json :_links)))

    (map nil (compose #'print links) '(:git :self :html))

    (fj:with-keys ((git :git)
                   (self :self)) (funcall links)
    
      (format t "~%~%First:~%~a~%~a~%~%"
              (funcall links :git) (funcall links :self))

      (rotatef git self)
      (format t "Swapped:~%~a~%~a~%~%"
              (funcall links :git) (fj:at json :_links "self"))

      (rotatef git self)
      (format t "Swapped back:~%~a%"
              (funcall links))))

    
#+END_SRC

** Use `fj:at` can mutate JSON

#+BEGIN_SRC lisp :results output
  (ql:quickload '(:functional-json :dexador :alexandria))
  (use-package :alexandria)

  (let* ((json (fj:o)))
    ;; setf-able with-keys
    (fj:with-keys ((wat :wat)
                   (obj :obj)) json
      (setf wat 43
            obj (fj:o :t1 34)))
    ;; at is setfable
    (setf (fj:at json "foo") 42)
    (setf (fj:at json "bar") (fj:o :new 80
                                   :test3 90))
    ;; setf multiple levels
    (setf (fj:at json "bar" "test") (fj:o :new 80
                                          :test3 90))
    (setf (fj:at json :key :field :nested) 10)
    (setf (fj:at json :key :field :other) 12)
    (setf (fj:at json :key "foo" "test") 90)
    (print json))
    
#+END_SRC

* TODO
Right now most query functions only work with jso association lists.
Many functions manipulate jso-alist directly.

I'd like to implement a hashtable version of the jso struct with hashtable compatible access methods.

One possibility is to jso a class with getjso and (setf getjso) methods.

** License
BSD

Copyright (c) 2025 Jeremiah LaRocco <jeremiah_larocco@fastmail.com>
Copyright (c) Streamtech & Marijn Haverbeke (marijnh@gmail.com)
