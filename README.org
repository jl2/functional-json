#+TITLE: About functional-json

This is a fork of [[https://marijnhaverbeke.nl/st-json/][ST-JSON]] with extra utilities to streamline
JSON processing and work with JSON from the REPL.

This fork aims to be backwards compatible with ST-JSON.

* Basic Usage

** Load JSON data using `fj:read-json` and `fj:with-keys` to access fields.

Field names can be "strings", :keywords, or 'symbols.

#+BEGIN_SRC lisp
  (ql:quickload '(:functional-json :dexador :alexandria))
  (use-package :alexandria)

#+END_SRC


#+BEGIN_SRC lisp :results output
  (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
         (json-list (fj:read-json (dex:get url)))
         (sorted-list (sort json-list #'< :key (fj:jsoλ :size)))
         (total-size 0))

    (loop :for json :in sorted-list :do
      (fj:with-keys ((name :name)
                     (size "size")
                     (type 'type)) json
        (incf total-size size)
        (format t "~a ~s, ~a bytes~%" type name size)))
    (format t "Total: ~a~%" total-size))
#+END_SRC

** Use `fj:jsoλ` to create access functions.

#+BEGIN_SRC lisp :results output
  (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
         (json-list (fj:read-json (dex:get url)))
         (html-link (fj:jsoλ :_links :html)))

    ;; Print all HTML links
    (mapc (compose #'print html-link) json-list)))
#+END_SRC


** Use `fj:at` to access fields.

#+BEGIN_SRC lisp :results output
   (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
          (json-list (fj:read-json (dex:get url :want-stream t)))
          (json (fj:at json-list 1)))


     ;; Index into arrays and lists using integers, into
     ;; objects using strings, symbols, or keywords
     (format t "First: ~a~%" (fj:at json-list 1 :_links))

     ;; Swap fields and make modifications
     ;; (setf at) doesn't support array/list indexing
     (rotatef (fj:at json :_links 'git)
              (fj:at json :_links "self") )
     (format t "Swapped: ~a~%" (fj:at json :_links))

     (rotatef (fj:at json :_links :git) (fj:at json :_links :self) )
     (format t "Swapped back: ~a~%" (fj:at json-list 1 :_links)))
#+END_SRC



** Use `fj:atλ` to create curried field access functions.

#+BEGIN_SRC lisp :results output
  (let* ((url "https://api.github.com/repos/jl2/functional-json/contents/")
         (json-list (fj:read-json (dex:get url :want-stream t)))
         (json (first json-list))
         (links (fj:atλ json :_links)))

    ;; Print specified links
    (mapc (compose #'print links) '(:git :self :html))

    ;; Can't setf through (funcall links)
    ;; but the object will see changes made with fj:with-key bindings and
    ;; through fj:at
    (fj:with-keys ((git :git)
                   (self :self)) (funcall links)
    
      (format t "~%~%First:~%~a~%~a~%~%"
              (funcall links :git) (funcall links :self))

      (rotatef git self)
      (format t "Swapped:~%~a~%~a~%~%"
              (funcall links :git) (fj:at json :_links "self"))

      (rotatef git self)
      (format t "Swapped back:~%~a%"
              (funcall links))))
#+END_SRC


** Use `fj:at` to build JSON

#+BEGIN_SRC lisp :results output
  ;; Start with empty object
  (let* ((json (fj:o)))

    ;; fj:with-keys bindings are setf-able, even if they didn't exist before
    (fj:with-keys ((wat :wat)
                   (obj :obj)) json
      (setf wat 43
            obj (fj:o :t1 34)))
    
    ;; fj:at is setfable
    (setf (fj:at json "foo") (fj:o))
    (setf (fj:at json :foo :bar) 47)
    (setf (fj:at json :bar :foo ) 48)
    (setf (fj:at json "bar") (fj:o :new 80
                                   :test3 90))
    ;; setf multiple levels of nested structure
    (setf (fj:at json "bar" "test") (fj:o :new 80
                                          :test3 90))
    (setf (fj:at json :key :field :nested) 10)
    (setf (fj:at json :key :field :other) 12)
    (setf (fj:at json :key "foo" "test") 90)

    (print json))
    
#+END_SRC


* TODO
Right now most query functions only work with jso association lists.
Many functions manipulate jso-alist directly.

I'd like to implement a hashtable version of the jso struct with hashtable compatible access methods.

One possibility is to jso a class with getjso and (setf getjso) methods.

** License
BSD

Copyright (c) 2025 Jeremiah LaRocco <jeremiah_larocco@fastmail.com>
Copyright (c) Streamtech & Marijn Haverbeke (marijnh@gmail.com)
